// Copyright (c) Amer Koleci and Contributors.
// Licensed under the MIT License (MIT). See LICENSE in the repository root for more information.

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Alimer.SourceGenerators;

[Generator]
internal sealed class TypeLibraryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<ExposedType> classDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
           fullyQualifiedMetadataName: AlimerTypes.ExposeAttribute,
           predicate: static (node, _) => node.IsClass() && node.IsPartial(),
           transform: static (context, token) =>
           {
               INamedTypeSymbol classSymbol = (INamedTypeSymbol)context.TargetSymbol;
               object? type = context
                   .Attributes[0]
                   .ConstructorArguments[0]
                   .Value;

               return new ExposedType(classSymbol, type);
           });

        IncrementalValueProvider<(Compilation Left, ImmutableArray<ExposedType> Right)> valueProvider =
            context
            .CompilationProvider
            .Combine(classDeclarations.Collect());

        context
            .RegisterSourceOutput(valueProvider, static (productionContext, source) => Execute(source.Left, source.Right!, productionContext));

        static void Execute(Compilation _, ImmutableArray<ExposedType> types, SourceProductionContext context)
        {
            foreach (ExposedType exposedType in types)
            {
                string source = Build(exposedType);
                context.AddSource($"{exposedType.Symbol.Name}.Type.g.cs", source);
            }
        }
    }

    public static string Build(in ExposedType exposedType)
    {
        var type = exposedType.Type;
        INamedTypeSymbol symbol = exposedType.Symbol;
        FormattedBuilder builder = new(new StringBuilder());

        builder
            .AppendAutoGenerated()
            .AppendLine()
            .AppendLine("using System.Text.Json.Nodes;")
            .AppendLine()
            .AppendLine($"namespace {symbol.ContainingNamespace.ToDisplayString()};")
            .AppendLine()
            .AppendLine($"{symbol.DeclaredAccessibility.AsString()} partial class {symbol.Name}")
            .AppendOpenBracer()
                .AppendLine($"static {symbol.Name}()")
                .AppendOpenBracer()
                .AppendLine($"global::Alimer.TypeLibrary.Register((services) => new {exposedType.Type}(services));")
                .AppendCloseBracer()
            //.Serialize(componentType)
            .AppendCloseBracer();

        return builder.ToString();
    }
}

internal readonly struct ExposedType(INamedTypeSymbol symbol, object? type)
{
    public readonly INamedTypeSymbol Symbol = symbol;
    public readonly object? Type = type;
}
