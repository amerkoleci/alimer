// Copyright (c) Amer Koleci and Contributors.
// Licensed under the MIT License (MIT). See LICENSE in the repository root for more information.

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Alimer.SourceGenerators;

[Generator]
internal sealed class SerializationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
       var classDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
           fullyQualifiedMetadataName: AlimerTypes.DefaultEntitySystemAttribute,
           predicate: static (node, _) => node.IsClass() && node.IsPartial(),
           transform: static (context, token) =>
           {
               INamedTypeSymbol classSymbol = (INamedTypeSymbol)context.TargetSymbol;
               object? type = context
                   .Attributes[0]
                   .ConstructorArguments[0]
                   .Value;

               return new ComponentType(classSymbol, type);
           });

        var valueProvider = context
            .CompilationProvider
            .Combine(classDeclarations.Collect());

        context
            .RegisterSourceOutput(valueProvider, static (productionContext, source) => Execute(source.Left, source.Right!, productionContext));

        static void Execute(Compilation _, ImmutableArray<ComponentType> assets, SourceProductionContext context)
        {
            foreach (var asset in assets)
            {
                string source = Build(asset);
                context.AddSource($"{asset.Symbol.Name}.g.cs", source);
            }
        }
    }

    public static string Build(in ComponentType componentType)
    {
        INamedTypeSymbol symbol = componentType.Symbol;
        //var type = assetType.Type;
        FormattedBuilder builder = new(new StringBuilder());

        builder
            .AppendAutoGenerated()
            .AppendLine()
            .AppendLine("using System.Text.Json.Nodes;")
            .AppendLine()
            .AppendLine($"namespace {symbol.ContainingNamespace.ToDisplayString()};")
            .AppendLine()
            .AppendLine($"{symbol.DeclaredAccessibility.AsString()} partial class {symbol.Name}")
            .AppendOpenBracer()
                .AppendLine($"static {symbol.Name}()")
                .AppendOpenBracer()
                .AppendLine($"global::Alimer.Engine.EntityManager.RegisterSystemFactory((services) => new {componentType.Type}(services));")
                .AppendCloseBracer()
            .Serialize(componentType)
            .AppendCloseBracer();

        return builder.ToString();
    }
}

internal readonly struct ComponentType(INamedTypeSymbol symbol, object? type)
{
    public readonly INamedTypeSymbol Symbol = symbol;
    public readonly object? Type = type;
}

internal static class FormattedBuilderExtensions
{
    public static FormattedBuilder Serialize(this FormattedBuilder builder, ComponentType componentType)
    {
        INamedTypeSymbol symbol = componentType.Symbol;
        if (symbol.IsAbstract)
            return builder;

        builder = builder
            .AppendLine()
            .AppendLine($"public override JsonObject Serialize()")
            .AppendOpenBracer()
                .AppendLine($"JsonObject json = new ()")
                .AppendOpenBracer()
                .AppendLine("{ \"__type\", " + $"\"{symbol.Name}\"" + " },")
                .AppendLine("{ \"__enabled\", " + $"IsEnabled" + " },")
                .AppendCloseBracer(";")
                .AppendLine()
                ;

        foreach (IPropertySymbol property in symbol.GetMembers().OfType<IPropertySymbol>())
        {
            if (property.IsStatic || property.IsReadOnly)
                continue;

            if (ShouldIgnore(property))
                continue;

            string jsonName = $"\"{property.Name}\"";

            switch (property.Type.SpecialType)
            {
                case SpecialType.System_Boolean:
                case SpecialType.System_SByte:
                case SpecialType.System_Int16:
                case SpecialType.System_Int32:
                case SpecialType.System_Int64:
                case SpecialType.System_Byte:
                case SpecialType.System_UInt16:
                case SpecialType.System_UInt32:
                case SpecialType.System_UInt64:
                case SpecialType.System_Single:
                case SpecialType.System_Double:
                case SpecialType.System_Char:
                case SpecialType.System_String:
                    builder = builder.AppendLine($"json.Add({jsonName}, {property.Name});");
                    break;
                default:
                    builder = builder.AppendLine($"json.Add({jsonName}, JsonUtilities.ToNode({property.Name}));");
                    break;
            }
        }

        return builder
            .AppendLine("return json;")
            .AppendCloseBracer()
                ;
    }

    public static bool ShouldIgnore(this ISymbol symbol)
    {
        if (symbol == null)
            throw new ArgumentNullException(nameof(symbol));

        AttributeData? jsonAttribute = symbol.GetAttributes().FirstOrDefault(attr => attr.AttributeClass!.Name == "IgnoreDataMemberAttribute");
        if (jsonAttribute != null)
        {
            return true;
        }

        jsonAttribute = symbol.GetAttributes().FirstOrDefault(attr => attr.AttributeClass!.Name == "JsonIgnoreAttribute");
        if (jsonAttribute != null)
        {
            return true;
        }

        return false;
    }
}
